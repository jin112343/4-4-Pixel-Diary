4×4 Pixel Diary モバイルアプリ – 要件定義と詳細設計
1. 背景と目的

イラストレーター きょーらさん が 2025 年 12 月 6 日に公開した実験的 Web サービス「4×4 Pixel Diary」では、利用者が 4×4 マスのドット絵（全 16 ピクセル）を描き、匿名でランダムな他の利用者と交換することができました。ユーザーは「おいしかったご飯」「綺麗だった景色」「楽しかった出来事」など自由に描き、その簡素なドット絵を通してカジュアルな“交換日記”を楽しんでいました
news.denfaminicogamer.jp
。ドット絵は 4×4 の制限で描き、カラーパレットから自由な色を選べる
news.denfaminicogamer.jp
上に、タイトルは最大 5 文字まで付けられます
news.denfaminicogamer.jp
。描いた絵を「こうかんする」ボタンで送信すると匿名で交換が始まり、相手の作品が「アルバム」に届きます
news.denfaminicogamer.jp
。送られてきたドット絵はアルバムに保管され、自分の作品はサーバーへ登録されて他人に届けられます
news.denfaminicogamer.jp
。

サービスは話題となり改修も進められましたが、意図しない使い方や NG ワード対策、受け取った絵の削除機能などを実装する必要がありました
news.denfaminicogamer.jp
。最終的には想定以上の反響で運営が難しくなり、12 月 8 日未明にサイトは閉鎖されました
news.denfaminicogamer.jp
。

本プロジェクトでは、この Web サービスのコンセプトをモバイルアプリに昇華し、Flutter を用いて iOS/Android 双方で動作するアプリケーションを開発します。基本機能の「ドット絵交換」に加え、アルバム機能、みんなの投稿を見るタイムライン、Bluetooth を使ったすれ違い通信（オフライン交換）、設定画面等を実装し、使いやすさ・安全性・拡張性をa兼ね備えたサービスを目指します。アーキテクチャは MVVM を採用し、状態管理には Riverpod、バックエンドは AWS 上の API／データストアを利用します。

2. システム全体概要
項目	内容
対象プラットフォーム	iOS / Android (Flutter でクロスプラットフォーム開発)
アーキテクチャ	MVVM パターン + Riverpod による状態管理
バックエンド	AWS (API Gateway + Lambda + DynamoDB + S3 + Cognito)
データ形式	4×4 ドット絵は 16 ピクセルの色情報を JSON または Base64 配列で保存。タイトルは UTF‑8 文字列 (最大 5 文字)
通信方式	HTTPS (インターネット経由)、Bluetooth Low Energy (端末間オフライン交換)
その他	匿名性の確保、NG ワードチェック、ログイン／ゲスト利用、オフライン対応、ダークモード対応
3. 機能要件
3.1 基本機能 – インターネット経由のドット絵交換

ドット絵作成

ユーザーは 4×4 のキャンバス上でタップしてドットを塗りつぶすことができる。使用できる色に制限は無く、カラーパレットから自由に選べる
news.denfaminicogamer.jp
。

描いたドット絵にはタイトル（最大 5 文字）を付けることができる
news.denfaminicogamer.jp
。タイトル入力時に文字数をバリデーションする。

交換操作

「こうかんする」ボタンを押すと、端末からサーバーにドット絵データとタイトルを送信し、ランダムな他ユーザーの作品を 1 件受け取る
news.denfaminicogamer.jp
。交換は匿名で行われる
news.denfaminicogamer.jp
。

サーバー側では未送信作品のキューを保持し、受け取りと同時に自分の作品をキューに登録する。二重受け取りを防ぐために排他制御を行う。

受信した作品は端末内のアルバムおよびサーバー側のユーザーアルバムに保存する。

アルバム閲覧

交換した作品はアルバム画面に時系列で保存され、サムネイル表示できる。

タップすると詳細ビューを開き、全 16 ピクセルを拡大表示し、タイトルや受信日時を確認できる。

NG ワードや不適切な絵を通報・削除する機能を提供。削除はローカルとサーバー両方から行う。

投稿 (みんなの作ったもの) タイムライン

ユーザーは自身の作品やアルバムに保存された作品を任意で公開投稿できる。投稿はニックネームまたは匿名で表示。

タイムライン画面では最新・人気順のフィードをスクロール形式で表示し、各投稿のドット絵、タイトル、いいね数、投稿者名を確認できる。

いいね・コメント機能を実装（コメントは 50 文字まで）。不適切な投稿は通報できる。

すれ違い通信 (Bluetooth LE)

端末間でインターネットがない状況でも交換できるように、Bluetooth LE による「すれ違い通信」を実装する。

交換に用いるデータは 16 ピクセルの色情報とタイトルのみ。送受信時は暗号化する。

端末はバックグラウンドで Advertising (発信) と Scanning (受信) を同時に行う。近接ユーザーが検出されると GATT を介して 1 対 1 の交換を行う。

交換が成功すると、双方の端末に新しいドット絵が保存され、オンラインになったタイミングでサーバーへ同期する。

設定画面

ログイン (AWS Cognito) ／ゲスト利用の切り替え、ニックネーム設定、通知設定、ダークモード設定を行う。

NG ワードフィルタのオン・オフ、コンテンツブロックリストの管理ができる。

保存済みデータのバックアップ／リストア、キャッシュ削除などの操作を提供。

3.2 管理機能

認証・ユーザー管理: AWS Cognito を用いてメール／SNS アカウントによるサインインと匿名利用をサポート。ユーザーはニックネームのみを公開し、個人情報を他ユーザーに開示しない。

モデレーション: サーバーサイドでタイトルの NG ワードフィルタを行い、不適切な言葉や暴力・卑猥な表現をブロックする
news.denfaminicogamer.jp
。ユーザーからの通報情報を管理画面で確認し、投稿やアカウントを停止できる。

分析・ログ: 利用状況やエラーを CloudWatch に記録し、ダッシュボードで可視化する。Bluetooth 交換の成功率や人気投稿などの統計を取得する。

4. 非機能要件

パフォーマンス: 交換操作は 3 秒以内に完了することを目標とする。アルバムやタイムラインはページングで 20 件ずつロードし、スクロールに遅延がないようキャッシュする。

信頼性: サーバーは AWS 上に冗長構成で配置し、99.9 % 以上の稼働率を目指す。交換データは DynamoDB に即時書き込まれ、S3 にオリジナルデータをバックアップする。Bluetooth 交換は通信エラー時に 3 回までリトライする。

セキュリティ: すべての API は HTTPS で暗号化する。AWS Cognito で JWT を発行し、認証が必要なエンドポイントを保護する。データベースには最小権限ポリシーを適用し、タイトルに NG ワードチェックを行う。不正アクセスや大量リクエストに対しては AWS WAF でレート制限する。

拡張性: 新しい機能 (例: グリッドサイズの拡張やスタンプ機能など) を容易に追加できるよう MVVM のモジュール構成を取る。API は REST で設計し、将来的には GraphQL に移行可能なようにデータモデルを整理する。

ユーザビリティ: フラットでシンプルな UI を採用し、片手で操作しやすいボタン配置にする。ドット絵の入力はタップ操作のみで完結し、カラーパレットは使いやすい UI を採用。アクセシビリティのため、コントラストの高い配色と VoiceOver/TalkBack 対応を検討する。

5. UI/UX 設計

以下は主要画面の概要です。ワイヤーフレームはテキストで表現しますが、実装時は Flutter の CustomPaint などを用いて描画します。

5.1 ホーム / ドット絵作成画面

ヘッダ: 画面タイトル「いまのきぶん」。右上に設定アイコン。

キャンバス: 4×4 の正方形グリッド。タップで現在選択中の色に塗りつぶし、長押しで元の色に戻す。下部に「戻る／やり直し」ボタン。色塗りの状態は ViewModel で管理。

カラーパレット: 「いろをえらぶ →」ボタンをタップするとダイアログが開き、HSV カラーホイールまたはプリセット色を表示。選択した色はカラーパレットボタン上に小さな四角で示す。

タイトル入力: テキストフィールド (最大 5 文字)。入力文字数が 5 を超えると警告を表示し、「こうかんする」ボタンが無効になる。

交換ボタン: 大きなコールトゥアクション「こうかんする」。押下時に ViewModel が検証→API 呼び出し→ローディングインジケータ表示→結果表示までのフローを管理。

アルバム導線: 画面下部のフッタに「アルバム」「投稿」「すれ違い」などのタブバーを設置。ホームは中央タブ。

5.2 アルバム画面

グリッドレイアウト (2 列) でサムネイルを表示。各アイテムにはタイトルと受信日時を添える。

スクロール時に一定数ずつ読み込む。タブ上部にはソート（新しい順・古い順）とフィルタ（タイトル検索）機能。

アイテムをタップすると詳細画面へ遷移し、元の 4×4 ドット絵を拡大表示。シェアボタン、削除ボタン、投稿ボタンを配置。

スワイプで前後の作品に移動できる。

5.3 投稿 (タイムライン) 画面

上部に「おすすめ」「新着」「自分の投稿」などのタブ。ListView.builder で無限スクロール実装。

各投稿カードにはドット絵サムネイル、タイトル、ニックネーム、いいねボタン／カウンタ、コメント数を表示。いいねは即座に反映され、非同期でサーバー更新。

投稿詳細ではコメントリストを表示し、コメント入力欄を配置。NG ワードチェックをフロント／バック双方で実施。

5.4 すれ違い通信画面

すれ違い通信をオン／オフするスイッチ、現在のステータス表示（広告発信中／周辺端末検出中など）。

検出された端末一覧を表示し、タップで即時交換を実行できる「手動交換モード」と、自動的に近くの端末と交換する「自動交換モード」を選択できる。

交換履歴を一覧化し、オフライン時の交換データが未同期の場合はアイコンを表示。オンライン時に自動同期。

5.5 設定画面

アカウント: ログイン／ログアウト、ニックネーム変更、削除依頼（アカウント削除）。

通知設定: 交換完了通知・いいね／コメント通知・Bluetooth 交換通知のオン／オフ。

テーマ設定: ライト／ダーク／システム連動。

プライバシー: NG ワードフィルタの有効／無効、ブロックリスト管理。

アプリ情報: バージョン情報、利用規約、プライバシーポリシー、オープンソースライセンス等。

6. データモデル設計
6.1 クライアント側 (Flutter)
エンティティ	主なフィールド
PixelArt	id (UUID), ownerId, title (<=5文字), pixels (長さ16の色コード配列), createdAt, receivedAt, source (server / bluetooth)
UserProfile	userId, nickname, avatarUrl, createdAt, settings (Map)
Album	userId, pixelArtList (List<PixelArt>), lastSyncedAt
Post	postId, pixelArtId, ownerId, likeCount, commentCount, createdAt, visibility (public/private)
Comment	commentId, postId, userId, content (50文字以内), createdAt
6.2 サーバー側 (AWS DynamoDB)

Table: PixelArt – パーティションキー id、ソートキー createdAt。属性: ownerId, title, pixels, status (未送信 / 待機中 / 送信済み), source, createdAt。

Table: ExchangeQueue – 未送信作品をランダムに返すためのキュー。属性: pixelArtId, ownerId, enqueuedAt。

Table: Album – パーティションキー userId、ソートキー receivedAt。属性: pixelArtId, title, pixels, source。

Table: Post – パーティションキー postId。属性: pixelArtId, ownerId, title, pixels, likeCount, commentCount, createdAt, public。

Table: Comment – パーティションキー postId, ソートキー commentId。属性: userId, content, createdAt。

実画像は 4×4 ピクセルなので、16個の色コード (例えば RGB 値を 3 バイトずつ) をそのまま文字列あるいは Base64 で DynamoDB / S3 に保存する。ユーザー認証は Cognito の userId で識別し、匿名ユーザーには一時的な guestId を付与する。

7. API 設計

すべての API は https://api.example.com/v1 以下に配置し、JWT 認証ヘッダを用いる。レスポンスは JSON。

HTTP	エンドポイント	説明
POST	/pixelart/exchange	クライアントが作成したドット絵 (pixels, title) を送信し、ランダムな他ユーザーの作品 1 件を返す。サーバーは ExchangeQueue から 1 件ポップし、受信ユーザーの Album と送信者の Album にそれぞれ保存する。NG ワードを検出した場合は 400 を返す。
GET	/album	認証済みユーザーのアルバム一覧を返す。パラメータ: lastEvaluatedKey (ページング)。
DELETE	/album/{pixelArtId}	指定した作品をアルバムから削除する。削除はソフトデリートで、後から復元可能。
POST	/post	自分のアルバムの作品を公開投稿として登録する。属性: pixelArtId, visibility。
GET	/posts	タイムライン取得。クエリ: `sort=newest
POST	/posts/{postId}/like	投稿にいいねする。二重いいねを防ぐため userId と postId の組み合わせでユニーク制約を設ける。
POST	/posts/{postId}/comment	コメントを追加。パラメータ: content。NG ワードチェックを行う。
GET	/posts/{postId}/comments	コメント一覧取得 (ページング対応)。
POST	/bluetooth/upload	オフラインで交換した作品データをまとめてサーバーへ同期する。リスト形式で送信し、サーバー側で Album へ登録する。

Lambda 関数では、ExchangeQueue 操作時に DynamoDB の条件付き書き込みを使用して同時アクセスを制御する。タイトル NG ワードチェックには Amazon Comprehend またはカスタム辞書を用いる。

8. アーキテクチャ構成
8.1 フロントエンド (Flutter + Riverpod)

Presentation (View): StatelessWidget / StatefulWidget を最小限にし、UI 部品のみを担当。ProviderScope で囲み、ConsumerWidget や HookConsumerWidget で ViewModel のデータを購読。

ViewModel: 画面ごとに ChangeNotifier 相当のクラスを用意し、StateNotifier や AsyncNotifier を Riverpod の provider として実装。API 呼び出し、状態管理、バリデーション、エラー処理をここで行う。

Model: データクラス (PixelArt, Post など) は freezed + json_serializable で生成。Repository インターフェースを定義し、ネットワーク層・ローカルキャッシュ層を抽象化。

Network: Dio や http パッケージを使って REST API を呼び出し、共通でリクエスト/レスポンスの変換を行う。トークンの自動更新やエラー共通処理を Interceptor にまとめる。

Local Storage: オフライン対応のために Hive または Isar を利用し、アルバムや交換待ちデータを端末内に保存する。Bluetooth 交換データもここに保持し、オンライン時に同期する。

8.2 バックエンド (AWS)
[Flutter App] --HTTPS--> [API Gateway] ---> [AWS Lambda] --(DynamoDB/S3)--> [Data Store]
                               |
                               ---> [AWS Cognito] (認証)


API Gateway: すべての REST API を集約し、ステージング (dev/stg/prod) に応じてエンドポイントを分離。リクエスト認証は Cognito User Pool オーソライザで行う。

AWS Lambda: エンドポイントごとにハンドラを作成。業務ロジック、NG ワードチェック、ExchangeQueue 制御、DynamoDB CRUD 操作を実装。Node.js または Python で実装し、テストを含める。

DynamoDB: 前述のテーブル構成。頻繁に更新される ExchangeQueue と Album テーブルはパーティションキー設計に注意し、スケーラビリティを確保。Global Secondary Index を活用してタイムラインや人気投稿のクエリに対応。

S3: 将来的に拡張する場合に備え、より大きなドット絵や画像ファイルを保存するバケットを用意。今回の 4×4 の場合は DynamoDB だけでも十分だが、柔軟性を考慮。

Cognito: ユーザー登録、ログイン、トークン発行。匿名利用者は Unauthenticated ID でアクセスし、ゲスト期間中でもアルバムや投稿を保持できる。

CloudWatch / EventBridge: 監視・ログ出力・定期的なデータメンテナンス (NG ワードリスト更新など) を実施。

9. Bluetooth すれ違い通信設計

使用技術: Flutter 側は flutter_blue_plus または flutter_reactive_ble を採用し、iOS/Android 両方で BLE Advertising & Scanning をサポートする。端末がバックグラウンドでも短時間の広告は可能だが、OS 制約のため 30 秒ごとに再広告する仕組みを導入する。

データ形式: BLE パケットのデータ領域は 20 バイト程度と小さいため、作品データは GATT 接続で送受信する。広告ではサービス UUID と簡易ハッシュを送信し、スキャン側が自分の端末と異なる端末を認識した場合に接続を開始する。

交換プロトコル:

A 端末が周辺に端末 B を検出すると、ランダムな nonce を生成しハンドシェイクを行う。

双方のアルバムから未送信作品を 1 件選択し、暗号化 (AES-CTR) したドット絵データとタイトルを送る。

受信後、端末は受け取った作品をローカル DB に保存し、送信済みフラグを設定する。

オフライン交換はローカルに記録し、オンラインになり次第 /bluetooth/upload API でサーバーへ同期する。重複チェックは作品 ID と交換時刻により行う。

UI 表示: 交換時は通知バーやアプリ内で「◯◯さんとドット絵を交換しました」と表示し、交換履歴には日時と端末 ID (ハッシュ化) を表示する。

セキュリティ対策: 交換対象を適切にフィルタするため、アプリはデバイス固有 ID を暗号化して伝え、ユーザーから判別できないようにする。不正なデータを受信した場合は破棄し、端末をブラックリスト登録する。

10. ユースケース／シーケンスフロー
10.1 インターネット交換のシーケンス

ユーザーがキャンバスでドット絵を描きタイトルを入力。

「こうかんする」をタップ → ViewModel が入力を検証。タイトルが 5 文字以内であることやキャンバスが未入力でないことを確認。

ViewModel は Repository 経由で /pixelart/exchange API を呼び出し、ドット絵データを送信。

Lambda 関数は NG ワードチェックを行い、問題なければ ExchangeQueue からランダムな作品をポップしてレスポンスに含める。同時に送信者の作品をキューへプッシュする。

クライアントはレスポンスを受け取り、アルバムに保存し、画面遷移せずにポップアップで「新しい絵が届きました」と通知。
news.denfaminicogamer.jp

ViewModel はサーバーから受信した作品をアルバム provider に追加し、UI を更新する。

10.2 投稿の流れ

アルバム詳細画面から「投稿」ボタンを選択。

投稿モーダルで公開設定（公開／非公開）、コメント受付可否を設定。

/post API を呼び出し、成功後はタイムラインに即時反映される。Riverpod の provider がリスナーに通知し、UI が更新される。

10.3 すれ違い交換のフロー

ユーザーが設定画面で「すれ違い通信」をオンにする。

アプリは BLE Advertising および Scanning を開始し、サービス UUID をブロードキャスト。

近隣の端末を検出すると、自動的にペアリングして作品交換プロトコルを実行。

交換完了後はローカルに保存し、オンライン時にサーバーへアップロードする。

11. 実装上の注意点

MVVM と Riverpod: 状態管理を適切に分離し、ビジネスロジックを ViewModel に集中させる。AsyncValue を用いて API 取得の状態 (loading/success/error) を表現し、UI 側では when でハンドリングする。テスト容易性のため Provider の依存関係注入を徹底する。

データの整合性: 同時に複数端末から交換リクエストが送られる可能性があるため、ExchangeQueue 操作は DynamoDB の ConditionExpression と TransactWrite を用いて排他制御する。Bluetooth 交換による重複投稿はサーバー側で pixelArtId と ownerId の組み合わせをユニークにして防止する。

NG ワード対策: タイトルやコメント入力時にクライアント側で軽度のフィルタリングを行いつつ、サーバー側で必ずチェックする。不適切な画像については検出が難しいため、ユーザーからの通報機能とモデレーターによる確認を導入する。

パフォーマンス最適化: ドット絵は小サイズなので通信量は少ないが、タイムラインやアルバムでは大量の画像ロードが予想されるため、CachedNetworkImage などを利用して画像キャッシュを行う。スクロール時の jank を防ぐために ListView.builder と SliverList を組み合わせる。

国際化 (i18n): 日本語を基本とし、英語など他言語対応を検討する。Flutter の intl パッケージで文字列を管理し、日付や時間のフォーマットをユーザーのロケールに合わせる。

12. 今後の展望

本アプリは 4×4 マスのドット絵というシンプルさが魅力である一方、ユーザーの創造性やコミュニケーション欲求を満たすために以下のような拡張も考えられます。

グリッドサイズのバリエーション: 8×8 や 16×16 など、より大きなキャンバスを選択可能にする。ただし描画の負担や通信量が増えるためオプションとして提供。

ステッカーやスタンプ機能: 限定スタンプを用いてデコレーションし、コレクション要素を強化する。

イベントやテーマ: 季節イベントやテーマ（例: ハロウィン、桜）を設定し、それに沿った投稿を募集。タイムラインでハッシュタグ的にまとめる。

分析機能: 人気の色やタイトル傾向などを統計としてフィードバックし、ユーザーの創作意欲を刺激する。

モバイルアプリ化により、Web サービスと比べてオフライン機能や通知機能が強化され、より身近な「交換日記」体験を提供できます。Flutter + Riverpod + AWS による堅牢なアーキテクチャは、今後の機能追加やユーザー数増加にも耐えられる構成です。

13. まとめ

「4×4 Pixel Diary」アプリは、日常の一コマをわずか 16 ピクセルに閉じ込めて誰かと交換するというユニークな体験をモバイル上で実現します。元となった Web サービスでは、色の制限なくドット絵を作成でき、タイトルは 5 文字までといったシンプルなルールで多くのユーザーが遊んでいました
news.denfaminicogamer.jp
。交換は匿名で行われ、アルバムに作品が蓄積されることもユーザーの楽しみになっていました
news.denfaminicogamer.jp
。

本設計では、これらの魅力を保持しつつ、投稿タイムラインや Bluetooth すれ違い通信、NG ワード対策などを盛り込み、安全かつ持続可能なサービスとすることを目指しました。MVVM と Riverpod によるクリーンなアーキテクチャ、AWS によるスケーラブルなバックエンド、そして Flutter のクロスプラットフォーム特性により、ユーザーに快適な体験を提供できるでしょう。


追加設計メモ：カレンダー表示と有料グリッド拡張

本書は先に提出した設計書に対する追加機能の設計メモです。日記のように日付別に作品を閲覧するカレンダー機能と、課金によって 4×4 グリッドを 5×5 に拡張するプレミアム機能を追加します。

1. 日記カレンダー機能
目的

ユーザーが過去に作成した作品を日付単位で振り返ることができるようにし、交換日記としての楽しさを高める。

UI・UX

月間カレンダー表示: Flutter 標準の CalendarDatePicker は月ごとの日付をグリッドで表示し、ユーザーが日付を選択できる
api.flutter.dev
。このウィジェットをベースに、作品がある日付にはドットや数値バッジを表示する。月の切り替えや年の変更はカレンダー自体のコントロールで可能。

日付選択時の詳細表示: カレンダーのセルをタップすると、その日に作成した作品一覧を下部のリストまたは新規ページに表示する。各作品カードにはドット絵サムネイル、タイトル、作成時間を載せ、アルバム詳細画面へ遷移できる。

新規作成導線: 作品がない日でも “+” ボタンを表示し、すぐにキャンバス画面に移動できるようにする。

データ構造と API

PixelArt には createdAt タイムスタンプがあり、これを日付単位でグループ化することでカレンダー用データを生成できる。

クライアント: カレンダー表示用の ViewModel (CalendarViewModel) を用意し、月をキーに Map<DateTime, List<PixelArt>> を保持する。月の切り替え時に必要なデータをローカルストレージや API から取得する。

サーバー: 新しい API GET /album?date=YYYY-MM-DD を追加し、指定日または日付範囲の作品を返す。ページングに対応し、必要であれば rangeStart/rangeEnd クエリで月単位の取得も可能とする。

オフライン対応

カレンダー画面で必要な情報はローカル DB（Hive/Isar）から取得できるようにし、通信環境が無い状態でも閲覧できるようにする。オンライン時はバックグラウンドで同期を行い、最新の状態を維持する。

2. 有料アップグレード：5×5 グリッド
概要

4×4 のキャンバスに 1 行 1 列を追加し、5×5（全 25 マス）のキャンバスで描ける機能を有料課金アイテムとして提供する。購入後は永続的にアンロックされる非消耗型アイテムとする。

課金実装

Flutter の in_app_purchase パッケージは App Store と Google Play を横断してアプリ内課金を提供する
pub.dev
。このプラグインでは、アプリ内商品を一覧表示し、消費型／非消費型アイテムやサブスクリプションを購入できる
pub.dev
。

ストアに商品 ID (pixel_diary_premium_grid) を登録し、価格や説明文を設定する。アプリ起動時に利用可能な商品を取得し、キャンバス画面のアップグレードボタンに価格を表示する。

購入処理は ViewModel (PurchaseViewModel) で管理し、purchaseStream を監視して購入成功／失敗を判定する。成功後はバックエンドに購入情報を送信し、ユーザーの gridSizeLimit を更新する。

データモデル拡張

UserProfile に gridSizeLimit (初期値 4) または hasPremiumGrid (bool) を追加。購入後は値を 5 または true に設定し、サーバー側のユーザーテーブルに保存する。Cognito のユーザーカスタム属性としても保持可能。

PixelArt モデルに gridSize プロパティを追加し、4×4 と 5×5 を区別できるようにする。pixels 配列の長さは gridSize² に等しい。既存の API は gridSize を受け取り、それに応じて交換キューを振り分ける。

UI 改良

キャンバス画面に 5×5 グリッドのプレビューを表示し、未購入の場合はロックアイコンと購入案内のダイアログを表示する。購入済みの場合は 5×5 キャンバスに切り替わり、色塗り操作は 25 マスに対して行える。

アルバムや投稿一覧では 4×4 と 5×5 のサムネイルサイズを自動調整し、統一された見た目を提供する。

設定画面に「購入履歴を復元」ボタンを追加し、端末変更時や再インストール後に課金アイテムを復元できるようにする。

交換ロジック

交換キューを gridSize ごとに分けることで、4×4 ユーザーが 5×5 作品を受け取ることがないようにする。API /pixelart/exchange は送信作品の gridSize を受け取り、対応するキューからランダムに作品を返す。

ユーザーへの付加価値

プレミアムグリッドを購入したユーザー向けに、プロフィールに特別なバッジを付与するなど特典を用意することでモチベーションを高める。

課金は永続的な非消耗型アイテムとし、再インストールや端末変更の際には restorePurchases を利用して自動的にアンロックされるようにする。

セキュリティ強化設計
1. 概要

Web版「4×4 Pixel Diary」は想定以上のアクセスと不適切な投稿により運営が困難となり、2025年12月にサービス終了しました。モバイルアプリ版では同様の問題を防ぐために、通信・データ保護・認証・ユーザー生成コンテンツ（UGC）・Bluetooth 通信・課金処理・運用の全てにおいて高水準のセキュリティ対策を実装します。ここでは MVVM＋Riverpod アーキテクチャ／AWS バックエンドという前提のもと、想定される攻撃モデルを整理し、それに対抗する設計方針を示します。

2. 基本方針

ゼロトラスト / 最小権限 – アプリからバックエンドまでのすべての境界で認証と認可を要求し、利用者・サービスに必要最小限の権限のみ付与します。

データ暗号化 – 通信中のデータは TLS で暗号化し、端末内のキャッシュやバックエンドストレージは暗号化済みの領域に保存します。証明書ピンニングにより中間者攻撃を防ぎます
enlabsoftware.com
。

強固な認証・認可 – Cognito／OAuth 2.1/OpenID Connect を採用し、短寿命トークン＋更新トークンでアクセスを制御し、必要に応じて MFA や生体認証を組み合わせます
enlabsoftware.com
。ロールベースアクセス制御（RBAC）により管理者機能と一般ユーザー機能を明確に分離します
enlabsoftware.com
。

API セキュリティ – サーバー側で全リクエストの入力検証を行い、リクエスト数の制限やエラーメッセージの最小化、署名・タイムスタンプによるリプレイ攻撃防止を実施します
enlabsoftware.com
。API Gateway ではレート制限やバースト設定を使用して DoS 攻撃を抑止します
octaria.com
。

秘密情報の安全な管理 – アプリには秘密鍵や API キーを埋め込まず、Android の Keystore／iOS の Keychain あるいは AWS Secrets Manager で暗号化して保管し、定期的に回転（ローテーション）します
enlabsoftware.com
。クライアント側では flutter_secure_storage を用いて暗号化済みのキー・トークンを保存し、Keystore / Keychain を活用します
digital.ai
。

コードハードニングと監視 – Flutter リリースビルドではコードを難読化し、アプリ改竄・ルート化検知を実装します
enlabsoftware.com
。CloudWatch と GuardDuty でログを集中管理し、不審な行動を検知したらアラートを発します。

継続的なセキュリティ運用 – CI/CD パイプラインに静的解析・依存ライブラリ脆弱性チェックを統合し、定期的なペネトレーションテストを実施します
enlabsoftware.com
。サプライチェーン攻撃を防ぐために第三者ライブラリの監査や署名済みリリースを徹底します
strobes.co
。

3. 通信とデータ保護
3.1 ネットワーク通信

HTTPS + TLS 1.3 – すべての通信を HTTPS 経由で行い、AWS ALB または CloudFront で TLS 1.3 を終端します。アプリ側は証明書ピンニングを実装し、正当なサーバーとしか通信しないよう検証します
enlabsoftware.com
。

証明書のローテーション – ACM で取得した証明書を定期的に更新し、ピンニングリストもアプリ更新時に更新します。

Bluetooth LE 暗号化 – すれ違い通信では BLE 4.2 以降の LE Secure Connections を使用し、ECDH による秘密共有で MITM 攻撃を防ぎます
argenox.com
。ペアリング方式は Passkey Entry または Numeric Comparison を採用し、Just Works を避けます
argenox.com
。GATT データはペアリング後に AES-CCM で暗号化します
argenox.com
。さらに MAC ランダム化を有効にしユーザー追跡を軽減します
argenox.com
。

3.2 データ保護

端末内の暗号化 – ユーザーのアルバムやオフライン交換データは Hive／Isar などのローカル DB を AES で暗号化して保存し、暗号鍵は flutter_secure_storage で保護します
digital.ai
。flutter_secure_storage は iOS の Keychain と Android の Keystore を利用し、機密データへの直接アクセスを防ぎます
digital.ai
。

最小データ収集 – アプリはドット絵・タイトル・ニックネームなど最低限の情報のみを収集します。端末固有 ID は UUID に変換し、広告 ID や精密な位置情報を取得しません。

暗号化アルゴリズム – BLE データ、Lambda 処理時の一時ファイル、データベースバックアップは AES-256-GCM により暗号化します。サーバー側では DynamoDB の暗号化（KMS）を有効化し、S3 バケットも SSE-KMS で暗号化します。

4. 認証と認可

Cognito + OAuth 2.1 – ユーザー登録・ログインには AWS Cognito を使用し、SNS 認証またはメール認証を提供します。アクセストークンは短寿命（15 分程度）とし、リフレッシュトークンで更新します
enlabsoftware.com
。ゲストユーザーには匿名資格証明を発行し、アクセス可能 API を制限します。

多要素認証(MFA) – 任意でメール／SMS／生体認証を組み合わせた MFA を導入し、不正ログインのリスクを軽減します。管理者アカウントには強制的に MFA を適用します
enlabsoftware.com
。

ロールベースアクセス制御(RBAC) – Lambda／DynamoDB の IAM ロールを細分化し、投稿削除やNGワードリスト管理といった管理機能は管理者権限のみが実行できます。UI 上での隠蔽だけでなく、バックエンドの認可で強制します
enlabsoftware.com
。

5. API セキュリティ

入力検証と正規化 – Lambda 関数はすべてのリクエストパラメータを型・長さ・内容で検証します。タイトルは長さ 5 文字以内、コメントは 50 文字以内、色コードは RGB のみ受け付けます。過剰な入力や不正な形式の場合は 400 エラーを返します。

レート制限と使用量管理 – API Gateway のレート制御機能を活用し、アカウントレベルでは 10 000 RPS、ステージレベルでは環境ごとに 5 000 RPS の上限を設けます
octaria.com
。また各クライアントには使用プランを設定し、通常ユーザーには 1 000 RPS とバースト 2 000 を割り当てます
octaria.com
。過剰アクセスは自動的に 429 Too Many Requests を返します。

署名とタイムスタンプ – 全リクエストに日時と乱数（nonce）を含め、サーバー側で一定時間内にしか受け付けないよう検証します。リプレイ攻撃を防止するため、同じ nonce の再利用をブロックします
enlabsoftware.com
。

WAF ルール – AWS WAF を導入し、SQL インジェクション・XSS・コモンボット検出を行うルールセットを適用します。さらに GeoIP ルールで不正地域からのアクセスを制限し、Rate-based ルールで IP 単位の短期レート制限を実施します。

エラーメッセージの最小化 – バックエンドは内部情報を漏らさないよう、エラーレスポンスは一般的なメッセージとエラーコードのみを返します
enlabsoftware.com
。

6. 秘密情報管理

秘密鍵の安全な保管 – API キーやデータベースの認証情報は AWS Secrets Manager または Parameter Store に格納し、KMS で暗号化します。Lambda 環境変数として読み込むときも権限を最小化します。秘密は定期的にローテーションし、不正使用が検出された場合は即時無効化します
enlabsoftware.com
。

クライアント側の安全な保存 – ユーザー認証トークン・BLE ペアリングキーなど端末内で保持する秘密は flutter_secure_storage に保存し、必要に応じて期限付きで破棄します
digital.ai
。アプリ公開用の API キーは使用せず、公開 API には署名付き URL を利用します。

ハードコーディングの禁止 – アプリやリポジトリに認証情報を埋め込まないよう、ビルドパイプラインで外部ファイルから読み込みます。OWASP Mobile Top 10 ではハードコードされた認証情報が重大なリスクとされており
strobes.co
、これを避けることが重要です。

7. コンテンツフィルタリングとプライバシー

画像／テキストのモデレーション – ユーザーが投稿・交換・日記に登録するタイトルやコメントを Amazon Comprehend でテキスト分類し、罵倒語や暴力表現を検出します。画像については Amazon Rekognition のモデレーション API を利用し、裸・暴力・武器・薬物・ヘイトシンボル・ギャンブルなどのカテゴリを検出します
getstream.io
。Rekognition はカテゴリごとに 0〜100 の信頼度スコアを返し、しきい値を運営ポリシーに合わせて調整できます
getstream.io
。

モデレーションフロー – 投稿や交換で画像がアップロードされる際、Lambda で先に S3 に保存し、Rekognition に URL を渡してモデレーションを実施します。処理結果がポリシーの範囲内なら投稿を公開し、拒否された場合はユーザーに警告を返します
getstream.io
。タイトルに NG ワードを含む場合はエラー応答とし、不適切なコメントはサーバー側で削除します。

ユーザー報告と人間の審査 – システムが検出できないグレーな内容に対処するため、ユーザーによる通報機能を提供し、管理者が審査できます。通報件数が閾値を超えた投稿は自動的に非表示にします。管理者のダッシュボードでは投稿者の履歴や通報理由を確認し、アカウント停止や作品削除を実施します。

プライバシー保護 – プロフィールやアルバムには個人情報を保存せず、ニックネーム以外は他ユーザーに公開しません。Bluetooth 交換時の相手機器識別情報はハッシュ化した ID とし、どの端末と交換したか追跡できないようにします。日記カレンダー機能では端末内にのみ日付と作品を保存し、共有しない限りサーバーに送信しません。

8. Bluetooth 交換の追加安全対策

すれ違い通信はインターネット接続がなくても動作するため、アプリ側で安全な手順を守る必要があります。

キー交換プロトコル – BLE LE Secure Connections の ECDH で共有秘密を生成し、それを用いて AES-CCM で作品データを暗号化します
argenox.com
。秘密鍵は端末の安全なストレージに保存します。

認証付きペアリング – ユーザーがすれ違い通信を許可するときは Passkey Entry や Numeric Comparison を要求し、MITM 攻撃に弱い Just Works を避けます
argenox.com
。

MAC ランダム化 – BLE 広告時に MAC アドレスをランダム化し、特定のユーザーを追跡できないようにします
argenox.com
。再接続のためにはペアリング時に共有した Long Term Key を用います
argenox.com
。

データ量と頻度の制限 – BLE パケットは小さいため、1 回の交換で 1 作品のみ送信し、交換回数に制限を設けてエネルギー消費やブルートフォース攻撃を抑止します。アプリはバックグラウンドでスキャンの間隔を制御しバッテリーを節約します。

ユーザー制御 – 設定画面に Bluetooth 交換のオン／オフ切り替え、近接ユーザー一覧表示、手動交換モードを設けます。不安なユーザーは常に手動承認を要求できます。

9. アプリケーションコードとサプライチェーンの安全性

コード難読化 – Flutter ビルド時に dart-obfuscation オプションを有効にし、ネイティブコードは Proguard/R8 で難読化します。アプリのデバッグ情報を削除し、スタックトレースに個人情報が含まれないようにします
enlabsoftware.com
。

ルート／ジェイルブレイク検知 – 端末がルート化・ジェイルブレイクされている場合にアプリ機能を限定または利用を拒否します。攻撃者がバイナリを解析するのを防ぐため、ランタイム改変検知やトラストチェッカーを実装します
enlabsoftware.com
。

サプライチェーン管理 – 依存ライブラリは公式の pub.dev から取得し、pubspec.lock でバージョンを固定します。CI で pub outdated を実行し、脆弱性が報告されたパッケージは速やかに更新します。OWASP の「不適切な認証情報管理」では、ハードコードされたライブラリ秘密や不適切なサプライチェーンが重大なリスクとなると指摘されています
strobes.co
。

ビルドプロセス – CI/CD 環境では署名済みリリース鍵を安全なビルドサーバーにのみ保存し、開発者端末には置きません。コードレビューと二人承認を通じて不正コードの混入を防ぎます。

10. ロギングと監視

集中ログ管理 – アプリとバックエンドは CloudWatch Logs に統合され、認証失敗、API エラー、モデレーション違反などのイベントを記録します。ログには個人を特定できる情報を含めず、必要に応じて匿名化します。

監査証跡 – CloudTrail で AWS リソースへのすべての API 呼び出しを記録し、誰がいつどの操作を行ったか追跡可能にします。Secrets Manager へのアクセスやポリシー変更は特に厳格に監視します。

アラート – GuardDuty や EventBridge を使って異常なパターン（不正ログイン試行、レート制限超過、異常な API 呼び出し）を検出し、Slack やメールにリアルタイム通知します。ペネトレーションテストツールや自動攻撃シミュレータを使ってアラートの有効性を検証します。

11. コンプライアンスと運用

個人情報保護法への対応 – 日本の個人情報保護法および GDPR に準拠し、ユーザーが自分のデータを閲覧・削除できる機能を実装します。データ保存期間のポリシーを定め、必要のないデータは削除します。

ユーザー同意と透明性 – 利用規約やプライバシーポリシーをアプリ内に明示し、交換や投稿時のデータ使用目的をユーザーに説明します。Bluetooth 機能や日記カレンダー機能は初回利用時に明示的な許可を得ます。

インシデント対応計画 – セキュリティ侵害が発生した際の責任者、連絡体制、初期対応フローを策定します。インシデント訓練を実施して準備します。

12. おわりに

本設計では、Web 版サービスの問題を踏まえて 徹底したセキュリティ対策 を盛り込みました。通信の暗号化や API のレート制限、強固な認証・認可、コンテンツモデレーション、秘密管理、Bluetooth の安全設計など、各層で防御を重ねる多層防御を採用しています。これにより、ユーザーの匿名性と自由な創作環境を守りながら、不適切なコンテンツや悪意ある攻撃からプラットフォームを防御します。今後も脆弱性や攻撃手法の進化に合わせて、CI/CD による継続的なアップデートと定期的なセキュリティレビューを行うことが重要です。